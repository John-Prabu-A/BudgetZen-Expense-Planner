/**
 * Persistence Layer
 * Handles saving detected transactions to the database
 */

import { supabase } from '../../supabase';
import {
    FinalTransactionRecord,
    IngestionResult,
    Platform,
    SourceType,
    TransactionCandidate,
} from '../types';

/**
 * Persistence Layer
 * Responsible for storing transactions and managing metadata
 */
export class PersistenceLayer {
  /**
   * Create transaction record from candidate
   */
  async createTransactionFromCandidate(
    candidate: TransactionCandidate,
    userId: string,
    accountId: string,
    confidenceThreshold: number = 0.5
  ): Promise<IngestionResult> {
    try {
      // Validate candidate
      if (!candidate.extractedData.amount || candidate.extractedData.amount <= 0) {
        return {
          success: false,
          error: 'Invalid amount',
          reason: 'Transaction amount is missing or invalid',
          messageId: candidate.id,
          metadata: { candidateId: candidate.id },
        };
      }

      if (candidate.confidenceScore < confidenceThreshold) {
        return {
          success: false,
          error: 'Low confidence',
          reason: `Confidence score ${candidate.confidenceScore} below threshold ${confidenceThreshold}`,
          messageId: candidate.id,
          metadata: { candidateId: candidate.id, confidence: candidate.confidenceScore },
        };
      }

      // Classify if not already done
      if (!candidate.classification) {
        return {
          success: false,
          error: 'Not classified',
          reason: 'Transaction candidate must be classified before persistence',
          messageId: candidate.id,
          metadata: { candidateId: candidate.id },
        };
      }

      // Build final record
      const finalRecord = this.buildFinalRecord(
        candidate,
        userId,
        accountId
      );

      // Check for duplicates
      const existingRecords = await this.findSimilarRecords(finalRecord);
      const isDuplicate = await this.checkDuplicate(finalRecord, existingRecords);

      if (isDuplicate) {
        return {
          success: false,
          error: 'Duplicate detected',
          reason: 'Similar transaction already exists in database',
          messageId: candidate.id,
          metadata: {
            candidateId: candidate.id,
            existingRecords: existingRecords.map(r => r.id),
          },
        };
      }

      // Create record
      const recordId = await this.persistRecord(finalRecord);

      // Store ingestion metadata
      await this.storeIngestionMetadata({
        recordId,
        candidate,
        sourceType: candidate.message.sourceType,
        platform: candidate.message.platform,
      });

      return {
        success: true,
        recordId,
        reason: 'Transaction created successfully',
        messageId: candidate.id,
        metadata: {
          candidateId: candidate.id,
          confidence: candidate.confidenceScore,
          source: candidate.message.sourceType,
        },
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        reason: 'Failed to persist transaction',
        messageId: candidate.id,
        metadata: { error: error.toString() },
      };
    }
  }

  /**
   * Build final transaction record
   */
  private buildFinalRecord(
    candidate: TransactionCandidate,
    userId: string,
    accountId: string
  ): FinalTransactionRecord {
    const deduplicationHash = this.generateDeduplicationHash(candidate);

    return {
      userId,
      type: candidate.classification!.type,
      amount: candidate.extractedData.amount || 0,
      accountId,
      categoryId: candidate.classification?.suggestedCategoryId || undefined,
      toAccountId: undefined, // For transfers, would be set by caller
      transactionDate: candidate.extractedData.date || new Date(),
      notes: candidate.extractedData.description || `Auto-detected: ${candidate.message.cleanText.substring(0, 100)}`,
      sourceMetadata: {
        source: candidate.message.sourceType,
        sourceId: candidate.id,
        platform: candidate.message.platform,
        confidence: candidate.confidenceScore,
        autoGenerated: true,
      },
      deduplicationHash,
    };
  }

  /**
   * Generate deduplication hash
   */
  private generateDeduplicationHash(candidate: TransactionCandidate): string {
    const data = {
      amount: candidate.extractedData.amount,
      date: candidate.extractedData.date?.toISOString().split('T')[0],
      type: candidate.extractedData.type,
      provider: candidate.extractedData.bankOrProvider,
      ref: candidate.extractedData.referenceNumber,
    };
    
    const json = JSON.stringify(data);
    // Simple hash - in production use crypto.subtle
    let hash = 0;
    for (let i = 0; i < json.length; i++) {
      const char = json.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash).toString(16);
  }

  /**
   * Find similar records in database
   */
  private async findSimilarRecords(record: FinalTransactionRecord): Promise<any[]> {
    try {
      // Query for transactions with similar amount and date
      const dateWindow = new Date(record.transactionDate);
      dateWindow.setDate(dateWindow.getDate() - 1); // 1 day window

      const { data, error } = await supabase
        .from('records')
        .select('*')
        .eq('user_id', record.userId)
        .eq('account_id', record.accountId)
        .eq('type', record.type)
        .gte('amount', record.amount * 0.99)
        .lte('amount', record.amount * 1.01)
        .gte('transaction_date', dateWindow.toISOString())
        .lte('transaction_date', record.transactionDate.toISOString());

      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('Error finding similar records:', error);
      return [];
    }
  }

  /**
   * Check if record is duplicate
   */
  private async checkDuplicate(
    record: FinalTransactionRecord,
    existingRecords: any[]
  ): Promise<boolean> {
    if (existingRecords.length === 0) return false;

    const similarityThreshold = 0.85;

    for (const existing of existingRecords) {
      // Check reference number exact match
      if (
        record.sourceMetadata?.sourceId &&
        existing.notes?.includes(record.sourceMetadata.sourceId)
      ) {
        return true;
      }

      // Check deduplication hash
      if (existing.notes?.includes(record.deduplicationHash)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Persist record to database
   */
  private async persistRecord(record: FinalTransactionRecord): Promise<string> {
    const recordData = {
      user_id: record.userId,
      type: record.type,
      amount: record.amount,
      account_id: record.accountId,
      to_account_id: record.toAccountId,
      category_id: record.categoryId,
      transaction_date: record.transactionDate.toISOString(),
      notes: record.notes,
      source_metadata: record.sourceMetadata,
      deduplication_hash: record.deduplicationHash,
    };

    const { data, error } = await supabase
      .from('records')
      .insert([recordData])
      .select('id')
      .single();

    if (error) throw error;
    return data.id;
  }

  /**
   * Store ingestion metadata
   */
  private async storeIngestionMetadata(metadata: {
    recordId: string;
    candidate: TransactionCandidate;
    sourceType: SourceType;
    platform: Platform;
  }): Promise<void> {
    try {
      const ingestionLog = {
        record_id: metadata.recordId,
        source_type: metadata.sourceType,
        platform: metadata.platform,
        raw_message: metadata.candidate.message.rawText,
        extracted_data: metadata.candidate.extractedData,
        confidence_score: metadata.candidate.confidenceScore,
        ingestion_timestamp: new Date().toISOString(),
        metadata: {
          intent: metadata.candidate.intent,
          bankProvider: metadata.candidate.extractedData.bankOrProvider,
          patterns: metadata.candidate.extractionDetails.matchedPatterns,
        },
      };

      await supabase
        .from('transaction_ingestion_logs')
        .insert([ingestionLog]);
    } catch (error) {
      console.warn('Warning: Could not store ingestion metadata:', error);
      // Non-critical, don't fail the transaction
    }
  }

  /**
   * Update transaction if needed
   */
  async updateTransaction(
    recordId: string,
    updates: Partial<FinalTransactionRecord>
  ): Promise<IngestionResult> {
    try {
      const updateData: any = {};
      
      if (updates.type) updateData.type = updates.type;
      if (updates.amount) updateData.amount = updates.amount;
      if (updates.categoryId) updateData.category_id = updates.categoryId;
      if (updates.notes) updateData.notes = updates.notes;
      if (updates.transactionDate) updateData.transaction_date = updates.transactionDate.toISOString();

      const { error } = await supabase
        .from('records')
        .update(updateData)
        .eq('id', recordId);

      if (error) throw error;

      return {
        success: true,
        recordId,
        reason: 'Transaction updated successfully',
        messageId: recordId,
        metadata: { updates },
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        reason: 'Failed to update transaction',
        messageId: recordId,
        metadata: { error: error.toString() },
      };
    }
  }

  /**
   * Get ingestion logs for debugging
   */
  async getIngestionLogs(
    userId: string,
    limit: number = 50
  ): Promise<any[]> {
    try {
      const { data, error } = await supabase
        .from('transaction_ingestion_logs')
        .select('*')
        .eq('user_id', userId)
        .order('ingestion_timestamp', { ascending: false })
        .limit(limit);

      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('Error fetching ingestion logs:', error);
      return [];
    }
  }
}

export const persistenceLayer = new PersistenceLayer();
